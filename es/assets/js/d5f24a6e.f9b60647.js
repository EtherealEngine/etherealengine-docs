"use strict";(self.webpackChunk_etherealengine_docs=self.webpackChunk_etherealengine_docs||[]).push([[5184],{6430:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var i=n(4848),o=n(8453);const l={},s="Client Files",r={id:"manual/modules/infrastructure/devopsDeployment/AWSSetup/clientFiles",title:"Client Files",description:"Ways of serving client files in production",source:"@site/docs/manual/03_modules/05_infrastructure/03_devopsDeployment/03_AWSSetup/01_clientFiles.md",sourceDirName:"manual/03_modules/05_infrastructure/03_devopsDeployment/03_AWSSetup",slug:"/manual/modules/infrastructure/devopsDeployment/AWSSetup/clientFiles",permalink:"/etherealengine-docs/es/manual/modules/infrastructure/devopsDeployment/AWSSetup/clientFiles",draft:!1,unlisted:!1,editUrl:"https://github.com/EtherealEngine/etherealengine-docs/blob/master/docs/manual/03_modules/05_infrastructure/03_devopsDeployment/03_AWSSetup/01_clientFiles.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"manual",previous:{title:"iR Engine on AWS",permalink:"/etherealengine-docs/es/manual/modules/infrastructure/devopsDeployment/AWSSetup/"},next:{title:"EKS",permalink:"/etherealengine-docs/es/manual/modules/infrastructure/devopsDeployment/AWSSetup/EKS"}},a={},c=[{value:"Ways of serving client files in production",id:"ways-of-serving-client-files-in-production",level:2},{value:"Serve client files from client pods",id:"serve-client-files-from-client-pods",level:3},{value:"Serve client files from API pods",id:"serve-client-files-from-api-pods",level:3},{value:"Serve client files from Storage Provider (S3 + Cloudfront)",id:"serve-client-files-from-storage-provider-s3--cloudfront",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"client-files",children:"Client Files"}),"\n",(0,i.jsx)(t.h2,{id:"ways-of-serving-client-files-in-production",children:"Ways of serving client files in production"}),"\n",(0,i.jsx)(t.p,{children:"There are multiple ways to serve built client files in a production environment.\nYou should decide how you want to serve them now, because a few later steps will be affected\nby that choice, and changing your AWS configuration after everything has been set up one way\nis a little tricky:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"From client pods (separate from API pods)"}),"\n",(0,i.jsx)(t.li,{children:"From API pods"}),"\n",(0,i.jsx)(t.li,{children:"From the storage provider, such as S3/Cloudfront"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"serve-client-files-from-client-pods",children:"Serve client files from client pods"}),"\n",(0,i.jsx)(t.p,{children:"This is the default method. The Helm charts assume that the deployment will have client pods\nto serve client files, and the client ingress will point traffic to the client pods. The client\nURL will be pointed to the EKS Load Balancer, and you will not need a separate client certificate."}),"\n",(0,i.jsx)(t.p,{children:"This option gives you slightly more flexibility in scaling a deployed cluster than serving\nfrom the API pods, since you can scale the number of API and client pods independently."}),"\n",(0,i.jsx)(t.p,{children:"Note that, as of this writing, this is tentatively going to be deprecated by a future re-architecture\nof how projects are built and served, and serving from the Storage Provider may end up being the only\nallowable option."}),"\n",(0,i.jsx)(t.h3,{id:"serve-client-files-from-api-pods",children:"Serve client files from API pods"}),"\n",(0,i.jsx)(t.p,{children:"This will make your builder build and serve the client service from the API pods. The Helm\nchart will not have a client deployment, serviceaccount, configmap, etc., and the client\ningress will point to the API pods. The client URL will be pointed to the EKS Load Balancer,\nand you will not need a separate client certificate."}),"\n",(0,i.jsxs)(t.p,{children:["To enable this, set client.serveFromApi to ",(0,i.jsx)(t.code,{children:"true"})," in your Helm config file when you are configuring it.\nThis needs to be applied to both the builder deployment and the main deployment, but if you set this\nbefore deploying anything, it will be applied to both."]}),"\n",(0,i.jsx)(t.p,{children:"This option can save you some money by requiring fewer nodes in order to host all of the\nAPI+client pods you desire, as you do not need capacity for separate client pods. It offers\nslightly less flexibility in scaling since you cannot scale the number of API and client pods\nseparately; more client capacity would require more API capacity, and vice versa. It also\nwill result in slightly longer deployment times, as the combined API+client Docker images\nare larger than an API-only or client-only image (though smaller than the sum of the two\nseparate images), which will mean a few more seconds to download to each node."}),"\n",(0,i.jsx)(t.p,{children:"Note that, as of this writing, this is tentatively going to be deprecated by a future re-architecture\nof how projects are built and served, and serving from the Storage Provider may end up being the only\nallowable option."}),"\n",(0,i.jsx)(t.h3,{id:"serve-client-files-from-storage-provider-s3--cloudfront",children:"Serve client files from Storage Provider (S3 + Cloudfront)"}),"\n",(0,i.jsx)(t.p,{children:"This will make the client build process push all of its built files to S3 and serve them via\nCloudfront. Static resources will also be served from the client domain instead of a separate\nresources domain. The client URL will be pointed to the Cloudfront distribution, not the EKS Load\nBalancer; only API and instanceserver traffic will go to the EKS cluster. You will need a separate\nclient certificate, but you will not need a resources domain certificate."}),"\n",(0,i.jsx)(t.p,{children:"As of this writing, only Amazon S3/Cloudfront is supported as a storage provider\nin a cloud environment."}),"\n",(0,i.jsxs)(t.p,{children:["To enable this, set builder.extraEnv.SERVE_CLIENT_FROM_STORAGE_PROVIDER to ",(0,i.jsx)(t.code,{children:"true"})," in the\nHelm config file when you are configuring it. Also make sure that builder.extraEnv.STORAGE_PROVIDER is set to ",(0,i.jsx)(t.code,{children:"s3"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This option can greatly speed up the time it takes for users to fully load your worlds,\nsince every client file can be served from a CDN close to them, rather than\nhaving to fetch them all from the closest physical server. It will also slightly speed up build times and deployment\ntimes since the client build does not need to be pushed to a Docker repo (though a cache of the build will still\nbe pushed to speed up future builds)."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},l=i.createContext(o);function s(e){const t=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(l.Provider,{value:t},e.children)}}}]);