"use strict";(self.webpackChunk_etherealengine_docs=self.webpackChunk_etherealengine_docs||[]).push([[9652],{4655:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var s=n(4848),i=n(8453);const o={},a="Spatial Input & WebXR",r={id:"manual/modules/spatial/spatialXRInput",title:"Spatial Input & WebXR",description:"Supporting multiple input sources",source:"@site/docs/manual/03_modules/02_spatial/02_spatialXRInput.md",sourceDirName:"manual/03_modules/02_spatial",slug:"/manual/modules/spatial/spatialXRInput",permalink:"/etherealengine-docs/es/manual/modules/spatial/spatialXRInput",draft:!1,unlisted:!1,editUrl:"https://github.com/EtherealEngine/etherealengine-docs/blob/master/docs/manual/03_modules/02_spatial/02_spatialXRInput.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"manual",previous:{title:"Turning entities into spatialized objects",permalink:"/etherealengine-docs/es/manual/modules/spatial/transforms"},next:{title:"Objects",permalink:"/etherealengine-docs/es/manual/modules/spatial/objects"}},c={},l=[{value:"Supporting multiple input sources",id:"supporting-multiple-input-sources",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"spatial-input--webxr",children:"Spatial Input & WebXR"}),"\n",(0,s.jsx)(t.h2,{id:"supporting-multiple-input-sources",children:"Supporting multiple input sources"}),"\n",(0,s.jsx)(t.p,{children:"Input can come from a variety of places:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"In non-immersive contexts"}),": It usually comes from a gamepad, mouse, keyboard, or screen touches."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"In immersive contexts"}),": It comes from the viewer's 6DOF perspective, and a variety of device-specific extensions such as 6DOF controllers, hands, gamepads, and potentially more."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Since this engine is immersive-first, the abstractions of easily unifying all these input sources are naturally to spatialize them where possible, and using WebXR and other web specifications to guide the API layers."}),"\n",(0,s.jsxs)(t.p,{children:["The first component to introduce is the ",(0,s.jsx)(t.code,{children:"InputSourceComponent"})," which stores the input source information according to the WebXR ",(0,s.jsx)(t.code,{children:"XRInputSource"})," interface, as well as generalized accessor for current button states and entity intersections."]}),"\n",(0,s.jsxs)(t.p,{children:["If the input source is spatial, it will have a ",(0,s.jsx)(t.code,{children:"TransformComponent"})," and ",(0,s.jsx)(t.code,{children:"XRSpaceComponent"}),", which stores the spatial information about the source."]}),"\n",(0,s.jsxs)(t.p,{children:["If the input source originates from a pointer (mouse or touch), it will store this information in an ",(0,s.jsx)(t.code,{children:"InputPointerComponent"}),", which also stores a reference to the HTML canvas object it originated from."]}),"\n",(0,s.jsxs)(t.p,{children:["During the input system phase, the ClientInputSystem calculates all the runtime information, such as transform and intersections for input sources. For each intersection, it also stores the intersecting input source entity on the first intersected entity if the ",(0,s.jsx)(t.code,{children:"InputComponent"}),' exists on that entity, which effectively specifies an entity is an input receiver. Input can be "captured" globally by an entity by mutating the ',(0,s.jsx)(t.code,{children:"capturingEntity"})," property on ",(0,s.jsx)(t.code,{children:"InputState"}),", which enforces that only that entity should receive input."]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);