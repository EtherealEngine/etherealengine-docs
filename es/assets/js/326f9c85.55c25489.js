"use strict";(self.webpackChunk_etherealengine_docs=self.webpackChunk_etherealengine_docs||[]).push([[969],{5688:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var r=t(4848),s=t(8453);const a={},o="Rendering Scenes",i={id:"manual/modules/spatial/cameraSceneRendering",title:"Rendering Scenes",description:"The RendererComponent defines the parameters for rendering a scene to render target (such as an HTML canvas or WebXR layer).",source:"@site/docs/manual/03_modules/02_spatial/04_cameraSceneRendering.md",sourceDirName:"manual/03_modules/02_spatial",slug:"/manual/modules/spatial/cameraSceneRendering",permalink:"/etherealengine-docs/es/manual/modules/spatial/cameraSceneRendering",draft:!1,unlisted:!1,editUrl:"https://github.com/EtherealEngine/etherealengine-docs/blob/master/docs/manual/03_modules/02_spatial/04_cameraSceneRendering.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"manual",previous:{title:"Objects",permalink:"/etherealengine-docs/es/manual/modules/spatial/objects"},next:{title:"World",permalink:"/etherealengine-docs/es/manual/modules/world/"}},c={},d=[];function l(e){const n={code:"code",h1:"h1",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"rendering-scenes",children:"Rendering Scenes"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"RendererComponent"})," defines the parameters for rendering a scene to render target (such as an HTML canvas or WebXR layer)."]}),"\n",(0,r.jsxs)(n.p,{children:["Scenes are simply defined as entity hierarchies. The ",(0,r.jsx)(n.code,{children:"SceneComponent"})," is used to specify which scene entities to render. Only the root of an entity hierarchy needs to be specified."]}),"\n",(0,r.jsxs)(n.p,{children:["Once an entity has both of these components, only a ",(0,r.jsx)(n.code,{children:"CameraComponent"})," is needed to actually render a scene. The camera provides a perspective from which to render the scene. The ",(0,r.jsx)(n.code,{children:"CameraComponent"})," specifies an ArrayCamera, which allows rendering one or more perspectives simultaneously."]}),"\n",(0,r.jsxs)(n.p,{children:["Upon the ",(0,r.jsx)(n.code,{children:"WebGLRendererSystem"})," running, it will aggregate the list of entities to render, and get the underlying objects from the GroupComponent into a flat list. This list is iterated, and pulls out a few extra parameters. The ",(0,r.jsx)(n.code,{children:"EnvironmentMapComponent"})," specifies the environment map to use for meshes that do not have an environment map already specified. The ",(0,r.jsx)(n.code,{children:"BackgroundComponent"})," specifies the skybox to render, either a Color, a Texture, or a CubeTexture. The ",(0,r.jsx)(n.code,{children:"FogComponent"})," specifies the fog parameters to use."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);